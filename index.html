<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>Title of the document</title>
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>
            body {
                background:#fff;
                padding:0;
                margin:0;
                font-weight: bold;
                overflow:hidden;
            }
        </style>
        <script src="lib/three.min.js"></script>
        <script src="lib/stats.min.js"></script>
        <script src="bundle.js"></script>
    </head>
    <body>
    </body>
    <!-- simulation & parsing -->
    <script type="text/javascript">
        var simulationData  = {
                robots:{},
                lines:[]
            };

        var replayData;
        var currentFrame;
        var parseFile = null;

        function parse(file){
            replayData = getData(file);
            currentFrame = 0;
            simulationData.robots = {};
            simulationData.lines = [];
        }

		function isMapParsed(){
			return replayData!=null && replayData.maplist.length>0 && replayData.maplist[0].frames.length>0;
		}

        function simulate(){
            if(replayData==null || replayData.maplist.length==0 || replayData.maplist[0].frames.length<=currentFrame+1)
                return;
            var frame = replayData.maplist[0].frames[currentFrame];
            var sigs = frame.signals;
            simulationData.lines = [];
            for(var i =0;i<sigs.length;i++){
                var sig = sigs[i];
                if(sig.type=="spawn"){
                    var robot = {
                        id:sig.robotID,
                        loc: sig.loc,
                        team: sig.team,
                        type: sig.robotType
                    };
                    simulationData.robots[robot.id] = robot;
                }else if(sig.type=="move"){
                    var robot = simulationData.robots[sig.robotID];
                    robot.loc = sig.loc;
                }else if(sig.type=="attack"){
                    var robot = simulationData.robots[sig.robotID];
                    simulationData.lines.push([robot,sig.loc]);
                }else if(sig.type=="death"){
                    delete simulationData.robots[sig.robotID];
                }
            }
            currentFrame++;
        }
    </script>
    <script type="text/javascript">
        var container, stats;
        var camera, scene, renderer;
        var objects,lines,walls;
        var redMaterial,blueMaterial,normalMaterial;
        var mouseX = 0, mouseY = 0;
        var windowHalfX = window.innerWidth / 2;
        var windowHalfY = window.innerHeight / 2;
        var frameNum = 0;
        var redCol = new THREE.Color(0xff0000);
        var blueCol = new THREE.Color(0x0000ff);
        document.addEventListener( 'mousemove', onDocumentMouseMove, false );
        init();
        animate();

        function init() {
            container = document.createElement( 'div' );
            document.body.appendChild( container );
            camera = new THREE.PerspectiveCamera( 80, window.innerWidth / window.innerHeight, 1, 10000 );
            camera.position.z = 1500;
            scene = new THREE.Scene();
            objects = [];

            var lineGeom = new THREE.Geometry();
            for(var i=0;i<2*100;i++){
                lineGeom.vertices.push(new THREE.Vector3(0,0,0));
                lineGeom.colors.push(new THREE.Color(0x00ff00));
            }
            lines = new THREE.Line(lineGeom,new THREE.LineBasicMaterial({linewidth:3,vertexColors:THREE.VertexColors}),THREE.LinePieces);
            scene.add(lines);

            var gridGeom = new THREE.Geometry();
            var gridNum = 30;
            var startGrid = -gridNum;
            var gridSize = 80;
            for(var x=-gridNum+1;x<gridNum;x++){
                gridGeom.vertices.push(new THREE.Vector3(x*gridSize,gridNum*gridSize,0));
                gridGeom.vertices.push(new THREE.Vector3(x*gridSize,-gridNum*gridSize,0));
            }
            for(var y=-gridNum+1;y<gridNum;y++){
                gridGeom.vertices.push(new THREE.Vector3(gridNum*gridSize,y*gridSize,0));
                gridGeom.vertices.push(new THREE.Vector3(-gridNum*gridSize,y*gridSize,0));
            }
            var grid = new THREE.Line(gridGeom,new THREE.LineBasicMaterial({color:0xCCCCCC}),THREE.LinePieces);
            scene.add(grid);

            normalMaterial = new THREE.MeshLambertMaterial( { color: 0xffffff } );
            var plane = new THREE.Mesh(new THREE.PlaneGeometry(gridNum*gridSize*2,gridNum*gridSize*2),normalMaterial);
            plane.position.z = -1;
            plane.receiveShadow = true;
            scene.add(plane);


            redMaterial = new THREE.MeshLambertMaterial( { color: 0xff0000 } );
            blueMaterial = new THREE.MeshLambertMaterial( { color: 0x0000ff } );
            var loader = new THREE.JSONLoader();
            loader.load( 'models/Suzanne.js', function ( geometry ) {
                geometry.computeVertexNormals();
                for ( var i = 0; i < 500; i ++ ) {
                    var mesh = new THREE.Mesh( geometry, normalMaterial );
                    mesh.position.z = 40;
                    mesh.visible = false;
                    mesh.castShadow = true;
                    mesh.scale.x = mesh.scale.y = mesh.scale.z = 40;
                    objects.push( mesh );
                    scene.add( mesh );
                }
            });

            //LIGHT
            var light = new THREE.DirectionalLight(0xffffff, 1);
            light.castShadow = true;
            //light.shadowCameraVisible = true;
            light.shadowCameraNear = 100;
            light.shadowCameraFar = 600;
            light.shadowCameraLeft = -2500; // CHANGED
            light.shadowCameraRight = 2500; // CHANGED
            light.shadowCameraTop = 2500; // CHANGED
            light.shadowCameraBottom = -2500; // CHANGED
            light.position.set(0,0,500); // CHANGED
            scene.add(light);

            renderer = new THREE.WebGLRenderer();
            renderer.shadowMapEnabled = true;
            renderer.shadowMapSoft = false;
            renderer.setClearColor( 0xffffff );
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            container.appendChild( renderer.domElement );

            stats = new Stats();
            stats.domElement.style.position = 'absolute';
            stats.domElement.style.top = '0px';
            stats.domElement.style.zIndex = 100;
            container.appendChild( stats.domElement );

            var fileChooser = document.createElement('input');
            fileChooser.style.position = 'absolute';
            fileChooser.style.top = '0px';
            fileChooser.style.left = '80px';
            fileChooser.style.zIndex = 100;
            fileChooser.type = 'file';
            fileChooser.onchange = function(){parseFile=this.files[0];};
            container.appendChild(fileChooser);
            window.addEventListener( 'resize', onWindowResize, false );
        }

        function onWindowResize() {
            windowHalfX = window.innerWidth / 2;
            windowHalfY = window.innerHeight / 2;
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize( window.innerWidth, window.innerHeight );
        }

        function onDocumentMouseMove(event) {
            mouseX = ( event.clientX - windowHalfX );
            mouseY = ( event.clientY - windowHalfY );
        }

		function createMap(){
			walls = new THREE.Mesh(new THREE.PlaneGeometry(1000,1000),normalMaterial);
			walls.position.z = 50;
			scene.add(walls);
		}
        function animate() {
            requestAnimationFrame( animate );

            if(parseFile!=null){
                parse(parseFile);
                parseFile = null;
            }
			if(isMapParsed() && walls==null){
				createMap();
			}
            if((frameNum++)%3==0)
                simulate();

            render();
            stats.update();
        }

        function locToMap(loc){
            var mapLoc = [0,0];
            var map = replayData.maplist[0];
            mapLoc[0] = (loc[0]-map.originX-map.width/2)*80;
            mapLoc[1] = -(loc[1]-map.originY-map.height/2)*80;
            return mapLoc;
        }

        function render() {
            //update camera
            var cameraAngle = (mouseX/windowHalfX)*Math.PI*2;
            var cameraRadius = 1000;
            camera.position.x = Math.sin(cameraAngle)*cameraRadius;
            camera.position.y = Math.cos(cameraAngle)*cameraRadius;
            camera.up.set(0,0,1);
            camera.lookAt( scene.position );

            //draw shoot lines
            var simulines = simulationData.lines;
            for(var i=0;i<lines.geometry.vertices.length;i+=2){
                if(i<simulines.length*2){
                    var robot = simulines[i/2][0];
                    var start = locToMap(robot.loc);
                    var end = locToMap(simulines[i/2][1]);
                    var col = robot.team=='A'?redCol:blueCol;
                    lines.geometry.vertices[i].set(start[0],start[1],(robot.type!='DRONE'?40:200)-20);
                    lines.geometry.vertices[i+1].set(end[0],end[1],0);
                    lines.geometry.colors[i].set(col);
                    lines.geometry.colors[i+1].set(col);
                }else{
                    lines.geometry.vertices[i].set(0,0,0);
                    lines.geometry.vertices[i+1].set(0,0,0);
                }
            }
            lines.geometry.verticesNeedUpdate = true;
            lines.geometry.colorsNeedUpdate = true;

            //update meshes
            var meshi = 0;
            for (var id in simulationData.robots){
                var robot = simulationData.robots[id];
                var mapLoc = locToMap(robot.loc);
                objects[meshi].position.x = mapLoc[0];
                objects[meshi].position.y = mapLoc[1];
                objects[meshi].position.z = robot.type!='DRONE'?40:200;
                objects[meshi].material = (robot.team=='A')?redMaterial:blueMaterial;
                objects[meshi].visible = true;
                meshi++;
            }
            for(var i=meshi;i<objects.length;i++){
                objects[i].visible = false;
            }

            renderer.render( scene, camera );
        }
    </script>
</html>

